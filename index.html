<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Freeview IPTV with EPG & Streams</title>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: linear-gradient(to right, #00204a, #003c8f);
    color: white;
    display: flex;
    height: 100vh;
  }
  .sidebar {
    width: 200px;
    background: #001d3d;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  .menu-item {
    font-size: 16px;
    opacity: 0.7;
    transition: 0.2s;
    padding: 5px 10px;
    border-left: 3px solid transparent;
    cursor: pointer;
  }
  .menu-item:hover,
  .menu-item.active {
    background-color: #0051a2;
    opacity: 1;
    border-left: 3px solid #00b4ff;
  }
  .main {
    flex: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
  }
  .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .logo {
    font-size: 24px;
    font-weight: bold;
    color: #00b4ff;
  }
  #time {
    font-size: 18px;
    margin-right: 10px;
  }
  .preview-box {
    margin-top: 20px;
    width: 320px;
    height: 180px;
    background: black;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #ccc;
  }
  video {
    width: 320px;
    height: 180px;
    background: black;
  }
  .epg {
    margin-top: 30px;
    background: rgba(255,255,255,0.05);
    padding: 15px;
    border-radius: 8px;
    overflow-y: auto;
    max-height: 60vh;
  }
  .epg table {
    width: 100%;
    border-collapse: collapse;
  }
  .epg th, .epg td {
    padding: 10px;
    border: 1px solid rgba(255,255,255,0.1);
  }
  .epg th {
    background: rgba(255,255,255,0.1);
  }
  .epg td {
    background: rgba(255,255,255,0.05);
  }
  .channel-name {
    cursor: pointer;
    color: #00b4ff;
    text-decoration: underline;
  }
</style>
</head>
<body>

<div class="sidebar">
  <div class="menu-item">Home</div>
  <div class="menu-item active">TV Guide</div>
  <div class="menu-item">Recordings</div>
  <div class="menu-item">Catch up TV</div>
  <div class="menu-item">On demand</div>
  <div class="menu-item">Best of Sky</div>
  <div class="menu-item">Sky Cinema</div>
  <div class="menu-item">Sky Store</div>
</div>

<div class="main">
  <div class="top-bar">
    <div class="logo">sky</div>
    <div id="time">--:--</div>
  </div>

  <div class="preview-box">
    <video id="player" controls autoplay muted></video>
  </div>

  <div class="epg">
    <h3>TV Guide</h3>
    <table id="epg-table">
      <thead>
        <tr><th>Channel</th><th>Now Showing</th><th>Next</th></tr>
      </thead>
      <tbody>
        <!-- Filled dynamically -->
      </tbody>
    </table>
  </div>
</div>

<script>
const m3uUrl = 'https://iptv-org.github.io/iptv/index.uk.m3u';
const epgUrl = 'https://raw.githubusercontent.com/dp247/Freeview-EPG/master/epg.xml';

function updateTime() {
  const now = new Date();
  let hours = now.getHours();
  let minutes = now.getMinutes();
  const ampm = hours >= 12 ? 'pm' : 'am';
  hours = hours % 12 || 12;
  minutes = minutes < 10 ? '0' + minutes : minutes;
  document.getElementById('time').textContent = `${hours}:${minutes}${ampm}`;
}

updateTime();
setInterval(updateTime, 10000);

// Parse M3U playlist, return array of {name, tvgId, url}
async function fetchM3U(url) {
  const res = await fetch(url);
  const text = await res.text();
  const lines = text.split('\n');
  const channels = [];
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith('#EXTINF')) {
      const infoLine = lines[i];
      const streamUrl = lines[i+1];
      // parse tvg-id and name
      const tvgIdMatch = infoLine.match(/tvg-id="([^"]+)"/);
      const tvgNameMatch = infoLine.match(/,(.*)$/);
      const tvgId = tvgIdMatch ? tvgIdMatch[1] : null;
      const name = tvgNameMatch ? tvgNameMatch[1].trim() : 'Unknown';
      channels.push({ name, tvgId, url: streamUrl });
      i++; // skip url line
    }
  }
  return channels;
}

// Parse XMLTV EPG, return array of channels and programmes
async function fetchEPG(url) {
  const res = await fetch(url);
  const text = await res.text();
  const parser = new DOMParser();
  const xml = parser.parseFromString(text, 'application/xml');

  // Channels
  const channelNodes = xml.querySelectorAll('channel');
  const channels = {};
  channelNodes.forEach(ch => {
    const id = ch.getAttribute('id');
    const displayNameNode = ch.querySelector('display-name');
    const displayName = displayNameNode ? displayNameNode.textContent : id;
    channels[id] = { id, displayName, programmes: [] };
  });

  // Programmes
  const programmeNodes = xml.querySelectorAll('programme');
  programmeNodes.forEach(pr => {
    const channel = pr.getAttribute('channel');
    const titleNode = pr.querySelector('title');
    const title = titleNode ? titleNode.textContent : 'No title';
    const start = pr.getAttribute('start'); // e.g. 20250607083000 +0000
    const stop = pr.getAttribute('stop');
    if (channels[channel]) {
      channels[channel].programmes.push({ title, start, stop });
    }
  });

  return Object.values(channels);
}

// Find best matching channel from EPG for a given M3U channel
function findMatchingEPGChannel(m3uChannel, epgChannels) {
  // Simple match by name ignoring case and spaces
  const nameToFind = m3uChannel.name.toLowerCase().replace(/\s+/g, '');
  return epgChannels.find(epgCh => epgCh.displayName.toLowerCase().replace(/\s+/g, '').includes(nameToFind));
}

function parseDateTime(dt) {
  // XMLTV datetime format: YYYYMMDDHHMMSS +0000
  // Convert to JS Date
  const dtClean = dt.split(' ')[0]; // strip timezone
  const year = parseInt(dtClean.substr(0,4));
  const month = parseInt(dtClean.substr(4,2)) - 1;
  const day = parseInt(dtClean.substr(6,2));
  const hour = parseInt(dtClean.substr(8,2));
  const minute = parseInt(dtClean.substr(10,2));
  const second = parseInt(dtClean.substr(12,2));
  return new Date(Date.UTC(year, month, day, hour, minute, second));
}

function getCurrentAndNextProgrammes(programmes) {
  const now = new Date();
  // sort programmes by start time ascending
  programmes.sort((a,b) => parseDateTime(a.start) - parseDateTime(b.start));
  let current = null;
  let next = null;

  for (let i = 0; i < programmes.length; i++) {
    const start = parseDateTime(programmes[i].start);
    const stop = parseDateTime(programmes[i].stop);
    if (now >= start && now < stop) {
      current = programmes[i];
      if (i + 1 < programmes.length) {
        next = programmes[i+1];
      }
      break;
    }
  }

  return { current, next };
}

function createTableRow(channel, streamUrl, currentProgram, nextProgram) {
  const tr = document.createElement('tr');

  const tdChannel = document.createElement('td');
  tdChannel.textContent = channel.displayName;
  tdChannel.classList.add('channel-name');
  tdChannel.onclick = () => {
    const player = document.getElementById('player');
    player.src = streamUrl;
    player.play();
  };
  tr.appendChild(tdChannel);

  const tdCurrent = document.createElement('td');
  tdCurrent.textContent = currentProgram ? currentProgram.title : 'No data';
  tr.appendChild(tdCurrent);

  const tdNext = document.createElement('td');
  tdNext.textContent = nextProgram ? nextProgram.title : 'No data';
  tr.appendChild(tdNext);

  return tr;
}

async function init() {
  try {
    const [channelsM3U, epgChannels] = await Promise.all([fetchM3U(m3uUrl), fetchEPG(epgUrl)]);

    const tbody = document.querySelector('#epg-table tbody');
    tbody.innerHTML = '';

    let count = 0;
    for (const chM3U of channelsM3U) {
      if (count >= 20) break; // limit to 20 channels initially
      const epgCh = findMatchingEPGChannel(chM3U, epgChannels);
      if (!epgCh) continue;

      const { current, next } = getCurrentAndNextProgrammes(epgCh.programmes);
      const tr = createTableRow(epgCh, chM3U.url, current, next);
      tbody.appendChild(tr);
      count++;
    }
  } catch (e) {
    console.error('Error initializing:', e);
  }
}

init();
</script>

</body>
</html>
